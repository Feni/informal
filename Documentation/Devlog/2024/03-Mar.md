# March 2024

## Mar 23
I've accidentlaly designed an OOP language. Let me explain.
Informal was always built on pure, immutable, functional core. I added objects as a way of managing isolated state and concurrency, but it was relegated as a special-case. But there was always a gap - at some level, you need to build the immutable functional things out of something. You need to translate that into hardware. Into real-world systems, and there was a semantic mismatch there which was bugging me.
Objects are that mapping to real world processes. Objects and functions are both equally powerful concepts. You can represent either one in terms of the other. But at the end of the day, the underlying hardware executing the program operates as a process - a series of instructions operating on memory. If we make objects the foundation, then we build up all other notions on top of it - including functions. 
What I'm defining as an object here is not the class-based Java style of objects - that OOP is concerned with modelling a domain as a class hierarchy - which has a lot of problems I won't get into here.
No - objects and classes in Informal are from the smalltalk family of objects - which are isolated, actor-like processes which encapsulate state and interact through messages.
Crucially, messages are *not* the same as functions. A message is a one way interaction between two objects. It is that arrow connecting one to the other. It doesn't require the object to respond to it. With one way messages, you can build higher-level types of communication patterns - like 1:1 call-response, 1:N broadcasts or iterator patterns, or other coordination systems. It is a more primitive unit of control-flow which can encode all types of behavior the system requires - from conditions, functions, exceptions, and concurrent actors.
Objects in Informal represent behavior or protocols between systems. It is that fabric in between things where all of the emergent properties happen - and also the layer which is typically invisible and unstructured. Informal formalizes these behaviors in a way you can analyze.
Each function will have a "process" method - serving as its main point of entry.
Within the process method, it can receive messages and specify what type it expects. It can send out other messages, and then expect particular replies. At the end of the process, it can terminate or continue by recursing back.
What this encodes is the interaction between system. If a process *expects* an "ack" message, but the other part of the system doesn't send it or sends it out of order, we can staticaly catch that. If there are two concurrent systems which are interacting with the system, it can enforce what the valid series of operations are at each state and catch race conditions at compile time. The system must be deterministically well behaved in all cases to fit the protocol.
This informally encodes a kind of linear type - encoding a series of operations in a particular order. That can catch issues like acquiring memory, without releasing it, or use-after-free, and more importantly - you can use it to model the expected processes in your own programs.
This gives us a way to fundamentally model mutable state, IO and many other pesky problems. These are the effects.
With objects as the basis, many other parts of the compiler fall into place. For example, managing scope, type-checking, "assignment" and more. You can represent all of those things completely in-language as just compile-time evaluated code. Giving you a very clean system that is homoiconic and self-represented.
Sometimes adding things makes the problem dramtically simpler across a broad spectrum of problems. That usually indicates it is the right design choice. Total minimalism is not the design principle - there's a difference between simplicity and minimalism. You can build hyper minimal systems out of very few primitives, but it is a mind-bending, convoluted puzzle to put together working systems out of that. Add concepts which simplify, and remove that which adds complexity.

-----------