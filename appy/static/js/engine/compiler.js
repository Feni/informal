/* 
Compiler / Interpreter which consumes the AST generated by parser
and either evaluates or generates bytecode
*/

import { JS_POST_CODE } from "./generator";

class Expr {
    constructor(cell, node) {
        // Store context relevant to this expression type
        this.cell = cell;
        this.node = node;
    }
    emitJs(target, gen) { 
        // Emits a js version of the expression and return a reference to it
        // target: Backend specific code emitter
        // gen: Language specific code generator
        console.log("Emit JS not implemented for " + this);
    }
    evaluate() { 
        // Evaluates the Expression and returns the result
        console.log("Evaluated not implemented for " + this);
    }
    static parse(cell, node) { 
        // Should parse the relevant bits from the node into a structure
        // Returns Expr node of given type
        console.log("Parse not implemented for " + this)
    }
}

const BINARY_OPS = {
    "and": "__aa_and",
    "or": "__aa_or",    
    "+": "__aa_add",
    "-": "__aa_sub",
    "*": "__aa_multiply",
    "/": "__aa_divide",
    "%": "__aa_mod",
    "<": "__aa_lt",
    ">": "__aa_gt",
    "<=": "__aa_lte",
    ">=": "__aa_gte",
    "==": "__aa_eq",
    "!=": "__aa_neq"
}

const UNARY_OPS = {
    "-": "__aa_uminus",
    "not": "__aa_not"
}

class BinaryExpr extends Expr {
    constructor(cell, node, left, right) {
        super(cell, node)
        // Expressions
        this.left = left;
        this.right = right;
        this.operator = BINARY_OPS[node.operator.keyword]
    }
    emitJS(target) {
        let left = this.left.emit_js(target)
        let right = this.right.emit_js(target)
        return target.function_call(this.operator, left, right)
    }
    static parse(cell, node) {
        let left = astToExpr(cell, node.left)
        let right = astToExpr(cell, node.left)
        return new BinaryExpr(cell, node, left, right);
    }
}

class UnaryExpr extends Expr {
    constructor(cell, node, left) {
        super(cell, node)
        this.left = left
        this.operator = UNARY_OPS[node.operator.keyword]
    }
    
    emitJS(target) {
        let left = this.left.emit_js(target)
        return target.function_call(this.operator, left);
    }
    static parse(cell, node) {
        let left = astToExpr(cell, node.left)
        return new UnaryExpr(cell, node, left)
    }
}

class LiteralExpr extends Expr {
    constructor(cell, node) {
        super(cell, node);
        // TODO: Type inference
    }
    emitJS(target) {
        return target.literal(this.node.value)
    }
}

class IdentifierExpr extends Expr {
    constructor(cell, node) {
        super(cell, node);
    }
    emitJS(target) {
        return target.identifier(this.node.value)
    }

}

class MapExpr extends Expr {

}

class ArrayExpr extends Expr {

}

class FilteringExpr extends Expr {

}

class InvokeExpr extends Expr {
    // Call/Invoke a "function" ()

}

class ConditionalExpr extends Expr {

}

class LoopExpr extends Expr {

}

class AssignmentExpr extends Expr {

}


class MemberExpr extends Expr {
    // Obj.attr dot access

}


function astToExpr(cell, node) {
    switch(node.type) {
        case "binary":
            return BinaryExpr.parse(cell, node)
        case "unary":
            return UnaryExpr.parse(cell, node)
        case "(literal)":
            return new LiteralExpr(cell, node)
        case "(identifier)":
            return new IdentifierExpr(cell, node)
        
    }
}


// Grouping?
class CodeGen {}
class JSCodeGen extends CodeGen {
    constructor(env) {
        this.env = env;
        this.variable_count = 0;
        this.code = JS_PRE_CODE;
    }

    functionCall(fn, ...args) {
        return fn + "(" + args.join(",") + ")"
    }

    declaration(name, value) {
        return "let " + name + " = " + value;
    }

    literal(value) {
        return JSON.stringify(value)
    }

    identifier(name) {
        return name
    }

    newVariable() {
        return "u_" + this.variable_count++;
    }

    emit(newCode) {
        this.code += newCode
    }

    emitTry() {
        this.emit("\ntry {\n");
    }

    emitCatchAll(cell) {
        this.emit(`} catch(err) {
            console.log(err); 
            ctx.setError("${cell.id}", err.message);
        }`);
    }
    
    emitCellResult(cell) {
        this.emit(
            this.function_call('ctx.set', "" + cell.id, cell.getCellName()) + ";")
    }

    emitCellError(cell, error, ...err_args) {
        this.emit(
            this.function_call(
                "ctx.set", 
                "" + cell.id, 
                this.error(error, ...err_args)
            ) + ";\n"
        )
    }

    error(err, ...args) {
        return "new " + err + "(" + args.join(",") + ")"
    }

    finalize() {
        this.code += JS_POST_CODE;
        return this.code
    }
}


export function compileJS(env) {
    var gen = new JSCodeGen(env);
    let exprs = [];
    if(env.root) {
        exprs.push(astToExpr(env.root, env.root.parsed));
    } else {
        Object.values(env.cell_map).forEach((cell) => {
            exprs.push(astToExpr(cell, cell.parsed))
        })
    }
}