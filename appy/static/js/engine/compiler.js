/* 
Compiler / Interpreter which consumes the AST generated by parser
and either evaluates or generates bytecode
*/

import { JS_PRE_CODE, JS_POST_CODE } from "../constants"
import { syntaxError } from "./parser";

const BINARY_OPS = {
    "and": "__aa_and",
    "or": "__aa_or",    
    "+": "__aa_add",
    "-": "__aa_sub",
    "*": "__aa_multiply",
    "/": "__aa_divide",
    "%": "__aa_mod",
    "<": "__aa_lt",
    ">": "__aa_gt",
    "<=": "__aa_lte",
    ">=": "__aa_gte",
    "==": "__aa_eq",
    "!=": "__aa_neq"
}

const UNARY_OPS = {
    "-": "__aa_uminus",
    "not": "__aa_not"
}

class Expr {
    constructor(cell, node) {
        // Store context relevant to this expression type
        this.cell = cell;
        this.node = node;
    }
    emitJS(target, gen) { 
        // Emits a js version of the expression and return a reference to it
        // target: Backend specific code emitter
        // gen: Language specific code generator
        console.log("Emit JS not implemented for " + typeof this);
        console.log(this);
    }
    evaluate() { 
        // Evaluates the Expression and returns the result
        console.log("Evaluated not implemented for " + typeof this);
    }
    static parse(cell, node) { 
        // Should parse the relevant bits from the node into a structure
        // Returns Expr node of given type
        console.log("Parse not implemented for " + this)
    }
}

class BinaryExpr extends Expr {
    constructor(cell, node, left, right) {
        super(cell, node)
        // Expressions
        this.left = left;
        this.right = right;
        this.operator = BINARY_OPS[node.operator.keyword]
    }
    emitJS(target) {
        let left = this.left.emitJS(target)
        let right = this.right.emitJS(target)
        return target.functionCall(this.operator, left, right)
    }
    static parse(cell, node) {
        let left = astToExpr(cell, node.left)
        let right = astToExpr(cell, node.right)
        return new BinaryExpr(cell, node, left, right);
    }
}

class UnaryExpr extends Expr {
    constructor(cell, node, left) {
        super(cell, node)
        this.left = left
        this.operator = UNARY_OPS[node.operator.keyword]
    }
    
    emitJS(target) {
        let left = this.left.emitJS(target)
        return target.functionCall(this.operator, left);
    }
    static parse(cell, node) {
        let left = astToExpr(cell, node.left)
        return new UnaryExpr(cell, node, left)
    }
}

class LiteralExpr extends Expr {
    constructor(cell, node) {
        super(cell, node);
        // TODO: Type inference
    }
    emitJS(target) {
        return target.literal(this.node.value)
    }
}

class IdentifierExpr extends Expr {
    constructor(cell, node) {
        super(cell, node);
    }
    emitJS(target) {
        return target.identifier(this.node.value)
    }
}

class KeySignatureExpr extends Expr {
    // TODO: Optional_index and rest_params
    constructor(cell, node, name, type, params, guard) {
        super(cell, node);
        this.name = name;
        this.type = type;
        this.params = params;
        this.guard = guard;
    }

    emitJS(target) {
        let paramSig = this.quoteParamJs(target);
        let guardSig = this.guard.emitJS(target);
        return target.create("KeySignature", '""', "null", paramSig, guardSig);
    }

    getParamJS(target) {
        return this.params.map((p) => p.emitJS(target));
    }

    quoteParamJs(target) {
        let paramSigs = this.params.map((p) => target.create("KeySignature", '"' + p.emitJS(target) + '"'));
        return target.array(paramSigs)
    }

    static parse(cell, node) {
        switch(node.node_type) {
            case "(identifier)":
                return new KeySignatureExpr(cell, node, astToExpr(cell, node.value))
            case "(grouping)":
                var params = node.value.map((p) => astToExpr(cell, p))
                return new KeySignatureExpr(cell, node, '""', "null", params)
            case "(if)":
                var guard, params;
                if(node.right) {
                    guard = astToExpr(cell, node.right);
                    params = node.left.value ? node.left.value.map((p) => astToExpr(cell, p)) : [];
                } else {
                    guard = astToExpr(cell, node.left);
                    params = [];
                }
                return new KeySignatureExpr(cell, node,  '""', "null", params, guard)
            default:
                // Note: Flat keys are not wrapped in a key signature.
                return astToExpr(cell, node)

        }
    }
}

class AssocExpr extends Expr {
    constructor(cell, node, key, value) {
        super(cell, node);
        this.key = key;
        this.value = value;
    }

    emitJS(target) {
        let mapName = target.newVariable();
        let obj = target.create("Obj");
        target.emit(target.declaration(mapName, obj) + ";\n")


        target.emit(target.method(mapName, "insert", this.getKeyJS(target), this.getValJS(target)) + ";\n")

        return mapName
    }

    getKeyJS(target) {
        console.log("This key is");
        console.log(this.key);
        if(Array.isArray(this.key)) {
            // TODO: Refactor grouping into a param node
            let paramSigs = this.key.map((p) => target.create("KeySignature", '"' + p.emitJS(target) + '"' ))
            
            // return "(" + .join(",") + ")"
            return target.create("KeySignature", '""', "null", target.array(paramSigs));
        } else {
            return this.key.emitJS(target)
        }
        
    }

    getValJS(target) {
        if(this.key instanceof KeySignatureExpr || Array.isArray(this.key)) {
            let fnBody = this.value.emitJS(target);
            let valName = target.newVariable();

            let params;
            if(Array.isArray(this.key)) {
                params = this.key.map((p) => p.emitJS(target))
            } else {
                params = this.key.getParamJS(target);
            }
            

            let valFn = target.declaration(valName, target.lambdaDeclaration(params, fnBody))
            target.emit(valFn);

            return valName;
        } else {
            return this.value.emitJS(target)
        }
    }

    static parse(cell, node) {
        let [k, v] = node.value;

        let key = astToExpr(cell, k);
        let value = astToExpr(cell, v);

        return new AssocExpr(cell, node, key, value);
    }

}

class MapExpr extends Expr {
    constructor(cell, node, kv_list) {
        super(cell, node);
        this.kv_list = kv_list;
    }

    emitJS(target) {
        let mapName = target.newVariable();
        let obj = target.create("Obj");
        target.emit(target.declaration(mapName, obj) + ";")

        this.kv_list.forEach((kv) => {
            target.emit(target.method(mapName, "insert", kv.getKeyJS(target), kv.getValJS(target)))
        })
        return mapName;
    }

    static parse(cell, node) {
        // Array of key-value tuples
        let kv_list = node.value.map( (kv_node) => {
            if(kv_node.node_type != "map") { syntaxError("Unexpected node found in map " + kv_node)}
            return AssocExpr.parse(cell, kv_node)
        });

        return new MapExpr(cell, node, kv_list)
    }
}

class ArrayExpr extends Expr {
    constructor(cell, node, elements) {
        super(cell, node)
        this.elements = elements;
    }
    emitJS(target) {
        let elements_js = this.elements.map((elem) => elem.emitJS(target))
        return target.functionCall("Stream.array", target.array(elements_js))
    }
    static parse(cell, node) {
        let elements = node.value.map((elem) => astToExpr(cell, elem))
        return new ArrayExpr(cell, node, elements);
    }
}

class FilteringExpr extends Expr {
    constructor(cell, node, arr, filter) {
        super(cell, node);
        this.arr = arr;
        this.filter = filter;
    }

    emitJS(target){
        return target.method(this.arr.emitJS(target), "get", this.filter.emitJS(target))
    }

    static parse(cell, node) {
        let arr = astToExpr(cell, node.left);
        let filter = astToExpr(cell, node.value[0]);
        return new FilteringExpr(cell, node, arr, filter)
    }
}

class InvokeExpr extends Expr {
    // Call/Invoke a "function" ()
    constructor(cell, node, fn, params) {
        super(cell, node);
        this.fn = fn;
        this.params = params;
    }

    emitJS(target) {
        let paramsJS = this.params.map((p) => p.emitJS(target))
        return target.functionCall("__aa_call", this.fn.emitJS(target), ...paramsJS)
    }

    static parse(cell, node) {
        let params = node.value.map((p) => astToExpr(cell, p))
        let fn = astToExpr(cell, node.left);
        return new InvokeExpr(cell, node, fn, params)
    }
}

class ConditionalExpr extends Expr {

}

class GuardExpr extends Expr {
    constructor(cell, node, condition, params) {
        super(cell, node);
        this.condition = condition;
        this.params = params;
    }

    emitJS(target) {
        console.log("Guard expression parts");
        console.log(this.params);
        console.log(this.condition);
        let name = target.newVariable();
        let paramsJS = this.params.map((p) => p.emitJS(target))
        let conditionBody = this.condition.emitJS(target)
        console.log("Guard fn: " + paramsJS + " => " + conditionBody);

        let guardFn = target.lambdaDeclaration(paramsJS, conditionBody)

        // TODO: toString for this
        return guardFn;
        
    }

    static parse(cell, node) {
        if(node.right) {
            let condition = astToExpr(cell, node.right);
            let params = astToExpr(cell, node.left);
            return new GuardExpr(cell, node, condition, params);
        } else {
            let condition = astToExpr(cell, node.left);
            let params = [];
            return new GuardExpr(cell, node, condition, params)
        }
    }
}

class LoopExpr extends Expr {

}

class AssignmentExpr extends Expr {

}


class MemberExpr extends Expr {
    // Obj.attr dot access
    constructor(cell, node, obj, attr) {
        super(cell, node);
        this.obj = obj;
        this.attr = attr;
    }

    emitJS(target) {
        // Quote the attribute name.
        return target.functionCall("__aa_attr", this.obj.emitJS(target), "" + this.attr.emitJS(target))
    }

    static parse(cell, node) {
        let obj = astToExpr(cell, node.left);
        let attr = astToExpr(cell, node.right);
        return new MemberExpr(cell, node, obj, attr)
    }

}

// Grouping?
class CodeGen {}
class JSCodeGen extends CodeGen {
    constructor(env) {
        super()
        this.env = env;
        this.variable_count = 0;
        this.code = JS_PRE_CODE;
    }

    functionCall(fn, ...args) {
        return fn + "(" + args.join(",") + ")"
    }

    lambdaDeclaration(params, body) {
        return `( ${params.join(",")} ) => {
            return ${ body }
        };
        `
    }

    method(obj, fn, ...args) {
        return obj + "." + fn + "(" + args.join(",") + ")"
    }

    create(cls, ...args) {
        return "new " + cls + "(" + args.join(",") + ")"
    }

    declaration(name, value) {
        return "var " + name + " = " + value;
    }

    literal(value) {
        return JSON.stringify(value)
    }

    identifier(name) {
        return name
    }

    array(elements) {
        return "[" + elements.join(",") + "]"
    }

    newVariable() {
        return "u_" + this.variable_count++;
    }

    emit(newCode) {
        this.code += newCode
    }

    emitTry() {
        this.emit("\ntry {\n");
    }

    emitCatchAll(cell) {
        this.emit(`} catch(err) {
            console.log(err); 
            ctx.setError("${cell.id}", err.message);
        }\n`);
    }
    
    emitCellResult(cell) {
        this.emit("\n");
        this.emit(
            this.functionCall('ctx.set', "" + cell.id, cell.getCellName()) + ";\n")
    }

    emitCellError(cell, error, ...err_args) {
        this.emit(
            this.functionCall(
                "ctx.set", 
                "" + cell.id, 
                this.error(error, ...err_args)
            ) + ";\n"
        )
    }

    error(err, ...args) {
        return "new " + err + "(" + args.join(",") + ")"
    }

    finalize() {
        this.code += JS_POST_CODE;
        return this.code
    }
}

export function astToExpr(cell, node) {

    // console.log("AST TO EXPR OF " + cell.id);
    if(!node || !node.node_type) { return undefined; }
    console.log(node.node_type);
    switch(node.node_type) {
        case "binary":
            return BinaryExpr.parse(cell, node)
        case "unary":
            return UnaryExpr.parse(cell, node)
        case "(literal)":
            return new LiteralExpr(cell, node)
        case "(identifier)":
            return new IdentifierExpr(cell, node)
        case "(grouping)": 
            console.log("Found grouping")
            if(node.value.length == 1) {
                console.log("Extracting grouping")
                // Swallow parens - order is explicit in the AST form
                let ret = astToExpr(cell, node.value[0])
                console.log(ret)
                return ret
            } else {
                // TODO: These should probably be split up into a separate tuple node type.
                return node.value.map((elem) => astToExpr(cell, elem))
            }
            
        case "apply":       // todo, NAME
            return InvokeExpr.parse(cell, node)
        case "(array)":
            return ArrayExpr.parse(cell, node)
        case "(where)":
            return FilteringExpr.parse(cell, node)
        case "(member)":
            return MemberExpr.parse(cell, node)
        case "map":         // TODO: name
            return AssocExpr.parse(cell, node)
        case "maplist":     // todo, NAME
            return MapExpr.parse(cell, node)
        case "(guard)":
            return GuardExpr.parse(cell, node)
        default:
            console.log("Unknown AST node type: " + node.node_type);
        
        
        
    }
}

export function compileJS(env) {
    var target = new JSCodeGen(env);

    env.exprAll(env.root);
    env.emitJS(env.root, target);

    return target.finalize()
}