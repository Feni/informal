{% extends "base.html" %}
{% load static from staticfiles %}

{% block extra_css %}
<link href='{% static "css/docs.css" %}?v=9' rel="stylesheet">
<link href='{% static "css/grip.css" %}?v=9' rel="stylesheet">

{% endblock %}

{% block sidebar %}
{% endblock %}

{% block content %}
<div class="page">
    <div id="preview-page" class="preview-page" data-autorefresh-url="">

    

      <div role="main" class="main-content">
        <div class="container new-discussion-timeline experiment-repo-nav">
          <div class="repository-content">
            <div id="readme" class="readme boxed-group clearfix announce instapaper_body md">
                            
              <article class="markdown-body entry-content" itemprop="text" id="grip-content">
                <h1>
<a id="user-content-a-new-language-for-the-web" class="anchor" href="#a-new-language-for-the-web" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A New Language For The Web</h1>
<p>AppAssembly is a general purpose programming language for building full-stack web applications. We take a handful of simple concepts and combine them in flexible ways to give you the full expressive power of a modern programming language, in a friendly visual environment. This guide walks you through all of the concepts you need to get started programming in AppAssembly.</p>
<p>You'll learn how to:</p>
<ul>
<li>Use array programming and pattern matching to reduce boilerplate code.</li>
<li>Write declarative code that favors plain data over abstractions.</li>
<li>Use functions to boost expressiveness throughout the language.</li>
<li>Incrementally add gradual typing to make your programs cleaner, faster and safer.</li>
<li>Replace regex with declarative patterns for common parsing tasks.</li>
<li>Get 4-16x the performance with seamless concurrency.</li>
<li>Simplify refactoring without breaking compatibility or requiring cascading changes.</li>
<li>Manage errors in a resilient way.</li>
<li>Extend and adapt the language to suit your needs.</li>
</ul>
<h2>
<a id="user-content-an-observable-visual-environment" class="anchor" href="#an-observable-visual-environment" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>An Observable Visual Environment</h2>
<p>Most bugs in software stem from a disconnect between our mental models of the problem and the complexities of reality. So often, we're coding blind with a limited input-output view into what our software is actually doing.
Observability is one of the fundamental principles of AppAssembly. Code should be transparent and interactive, so it's easy to understand and easy to change.
We do this by connecting you directly to your running system, so you can explore the problem domain and incrementally compose code that you can see and interact with.</p>
<p>To get started, try playing around with the expression in the cells below:</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s">"Hello, "</span> + <span class="pl-s">"world!"</span>
<span class="pl-c"># "Hello World"</span></pre></div>
<p>All code in AppAssembly lives in these spreadsheet-like cells. You can write entire programs in these cells, but we recommend building your program out of many smaller cells you can observe.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">1</span> + <span class="pl-c1">1</span>        <span class="pl-c"># 1</span>
<span class="pl-c1">10</span> * <span class="pl-c1">2.5</span>     <span class="pl-c"># 25.0</span></pre></div>
<p>Cells have a name and an expression. You can reference a cell by its name and when the cell value changes, all of its references are automatically updated. Just like in Excel.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">n</span> <span class="pl-c1">=</span> <span class="pl-c1">5</span>
<span class="pl-s1">squared</span> <span class="pl-c1">=</span> <span class="pl-s1">n</span> * <span class="pl-s1">n</span>
<span class="pl-c"># 25</span></pre></div>
<p>Cells are lexically scoped to the block they're defined in. They're order-independent, so you can think of them as stating facts that always hold true rather than issuing instructions.</p>
<p>Cells contain values, but they're not mutable variables. Values are immutable. Just like you don't mutate the meaning of a number when you do <code>2 + 3</code> or mutate a string when you do <code>"hello".uppercase()</code>, all operations return a new transformed value. Values are easier to observe and reason about than state which may be mutated by each line of code. Under the hood, this is equivalent to the SSA (Static Single Assignment) form that many compilers use to optimize code.
Even though values are immutable, you can re-bind a name to a new value using <code>=</code> for a familiar coding style.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">n</span> <span class="pl-c1">=</span> <span class="pl-c1">5</span>
<span class="pl-s1">n</span> <span class="pl-c1">=</span> <span class="pl-s1">n</span> * <span class="pl-c1">2</span>
<span class="pl-c"># n = 10</span></pre></div>
<p>Later on, you'll see how you can use <em>Actions</em> to manage state changes in a concurrency safe way.</p>
<h2>
<a id="user-content-array-programming" class="anchor" href="#array-programming" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Array Programming</h2>
<p>Lists in AppAssembly let you group elements together into a larger unit you can operate on.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-kos">[</span><span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-c1">3</span><span class="pl-kos">]</span>
<span class="pl-c"># [1, 2, 3]</span></pre></div>
<p>Lists can contain data of various types.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-kos">[</span><span class="pl-c1">9</span><span class="pl-kos">,</span> <span class="pl-c1">27.0</span><span class="pl-kos">,</span> <span class="pl-c1">true</span><span class="pl-kos">,</span> <span class="pl-c1">false</span><span class="pl-kos">,</span> <span class="pl-s">"hello"</span><span class="pl-kos">,</span> <span class="pl-pds">:symbol</span><span class="pl-kos">]</span></pre></div>
<p>You can perform operations over the entire collection. No loops required!</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">2</span> * <span class="pl-kos">[</span><span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">20</span><span class="pl-kos">,</span> <span class="pl-c1">30</span><span class="pl-kos">]</span>
<span class="pl-c"># [20, 40, 60]</span>
<span class="pl-kos">[</span><span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">20</span><span class="pl-kos">,</span> <span class="pl-c1">30</span><span class="pl-kos">]</span> + <span class="pl-kos">[</span><span class="pl-c1">5</span><span class="pl-kos">,</span> <span class="pl-c1">5</span><span class="pl-kos">,</span> <span class="pl-c1">5</span><span class="pl-kos">]</span>
<span class="pl-c"># [15, 25, 35]</span></pre></div>
<p>Multi-dimensional arrays are created by defining each row on its own line.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">0</span>
<span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">0</span>
<span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">1</span>
<span class="pl-c"># [[1, 0, 0]</span>
<span class="pl-c">#  [0, 1, 0]</span>
<span class="pl-c">#  [0, 0, 1]]</span>
<span class="pl-s1">center_row</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">0</span><span class="pl-kos">]</span>  <span class="pl-c"># Use ;; to define it inline</span>
<span class="pl-s1">matrix</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">0</span><span class="pl-kos"></span> <span class="pl-kos">;</span><span class="pl-kos">;</span> <span class="pl-s1">center_row</span> <span class="pl-kos">;</span><span class="pl-kos">;</span> <span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">1</span><span class="pl-kos">]</span>
<span class="pl-c"># [[1, 0, 0]</span>
<span class="pl-c">#  [0, 1, 0]</span>
<span class="pl-c">#  [0, 0, 1]]</span></pre></div>
<p>Use <code>;</code> (read as "followed by") to combine lists, or to append or prepend elements onto a list. You can also use the spread syntax, <code>...</code>, to expand a list in-place.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">arr</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-c1">3</span><span class="pl-kos">]</span>
<span class="pl-s1">brr</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">20</span><span class="pl-kos">,</span> <span class="pl-c1">30</span><span class="pl-kos">]</span>
<span class="pl-s1">sub_arrays</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-s1">arr</span><span class="pl-kos">,</span> <span class="pl-s1">brr</span><span class="pl-kos">]</span>
<span class="pl-c"># [[1, 2, 3], [10, 20, 30]]</span>
<span class="pl-s1">spread_array</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-s1">arr</span><span class="pl-kos">,</span> ...<span class="pl-s1">brr</span><span class="pl-kos">]</span>
<span class="pl-c"># [[1, 2, 3], 10, 20, 30]</span>
<span class="pl-s1">combined</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-s1">arr</span><span class="pl-kos"></span><span class="pl-kos">;</span> <span class="pl-s1">brr</span><span class="pl-kos">]</span>
<span class="pl-c"># [1, 2, 3, 10, 20, 30]</span>
<span class="pl-kos">[</span><span class="pl-c1">99</span><span class="pl-kos"></span><span class="pl-kos">;</span> <span class="pl-s1">arr</span><span class="pl-kos">]</span>
<span class="pl-c"># [99, 1, 2, 3]</span>
<span class="pl-kos">[</span><span class="pl-s1">arr</span><span class="pl-kos"></span><span class="pl-kos">;</span> <span class="pl-c1">99</span><span class="pl-kos">,</span> <span class="pl-c1">100</span><span class="pl-kos">]</span>
<span class="pl-c"># [1, 2, 3, 99, 100]</span></pre></div>
<h3>
<a id="user-content-declarative-ranges" class="anchor" href="#declarative-ranges" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Declarative Ranges</h3>
<p>Whenever possible, AppAssembly tries to define operations in a declarative style where you specify what the result should look like, rather than use separate functions like <code>concat</code>, <code>append</code>, <code>prepend</code>, <code>range</code>, etc.</p>
<p>For example, to create a range of numbers, just specify the beginning and end.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-kos">[</span><span class="pl-c1">1</span>..<span class="pl-c1">10</span><span class="pl-kos">]</span>
<span class="pl-c"># [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></pre></div>
<p>You can list out the first few elements and the range expression will determine the step and fill in the values in between.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-kos">[</span><span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">20</span><span class="pl-kos">,</span> .. <span class="pl-c1">100</span><span class="pl-kos">]</span>
<span class="pl-c"># [10, 20, 30, 40, 50, 60, 70, 80, 90]</span></pre></div>
<p>We can make this an inclusive range by specifying elements that would appear after the range with a comma <code>..,</code></p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-kos">[</span><span class="pl-c1">100</span><span class="pl-kos">,</span> <span class="pl-c1">90</span><span class="pl-kos">,</span> ..<span class="pl-kos">,</span> <span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">0</span><span class="pl-kos">]</span>
<span class="pl-c"># [100, 90, 80, 70, 60, 50, 40, 30, 10, 0]</span></pre></div>
<p>Ranges can figure out any sequences that can be expressed as <code>a*x + b</code>, so you can count up, down or sideways.
They work on other data types as well, including characters.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">hex_characters</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-s">"0"</span>..<span class="pl-kos">,</span><span class="pl-s">"9"</span><span class="pl-kos"></span><span class="pl-kos">;</span> <span class="pl-s">"a"</span>..<span class="pl-kos">,</span><span class="pl-s">"f"</span><span class="pl-kos">]</span>
<span class="pl-c"># ["0", "1, "2", "3", "4", "5", ...]</span></pre></div>
<p>If we leave out the last element, we get a an infinite sequence.
Ranges are generated lazily on-demand, so these operations are fast and don't take up any extra space in memory.</p>
<p>Soon, with functions, you'll be able to generate any arbitrary sequence you can imagine!</p>
<h3>
<a id="user-content-composable-filtering" class="anchor" href="#composable-filtering" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Composable Filtering</h3>
<p>You can get the element at a particular position in the list using the index operator <code>[]</code></p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">arr</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">20</span><span class="pl-kos">,</span> <span class="pl-c1">30</span><span class="pl-kos">,</span> ..<span class="pl-c1">100</span><span class="pl-kos">]</span>
<span class="pl-s1">arr</span><span class="pl-kos">[</span><span class="pl-c1">0</span><span class="pl-kos">]</span>
<span class="pl-c"># 10</span></pre></div>
<p>List indices start at zero. Use a negative index to lookup an item from the end.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">arr</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">5</span><span class="pl-kos">,</span> <span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">15</span><span class="pl-kos">,</span> <span class="pl-c1">20</span><span class="pl-kos">,</span> <span class="pl-c1">25</span><span class="pl-kos">]</span>
<span class="pl-s1">arr</span><span class="pl-kos">[</span>-<span class="pl-c1">1</span><span class="pl-kos">]</span>
<span class="pl-c"># 25</span></pre></div>
<p>Indexing is just a special case of filtering. So you can also pass in a list of indexes and it'll filter the list to the elements at those indexes, in the given order.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">arr</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">5</span><span class="pl-kos">,</span> <span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">15</span><span class="pl-kos">,</span> <span class="pl-c1">20</span><span class="pl-kos">,</span> <span class="pl-c1">25</span><span class="pl-kos">]</span>
<span class="pl-s1">arr</span><span class="pl-kos">[</span>-<span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-c1">0</span><span class="pl-kos">]</span>
<span class="pl-c">#[25, 15, 0]</span></pre></div>
<p>Combining this indexing with the range operation, you can access array slices using the same syntax</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">arr</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">20</span><span class="pl-kos">,</span> <span class="pl-c1">30</span><span class="pl-kos">,</span> <span class="pl-c1">40</span><span class="pl-kos">,</span> <span class="pl-c1">50</span><span class="pl-kos">]</span>
<span class="pl-s1">arr</span><span class="pl-kos">[</span><span class="pl-c1">1</span>..<span class="pl-kos">]</span>        <span class="pl-c"># Get elements at index 1, 2, 3 ... (all elements except first)</span>
<span class="pl-c"># 20, 30, 40, 50</span>
<span class="pl-s1">arr</span><span class="pl-kos">[</span>..-<span class="pl-c1">1</span><span class="pl-kos">]</span>       <span class="pl-c"># Get all elements except last</span>
<span class="pl-c"># 10, 20, 30, 40</span></pre></div>
<p>You can also index with a boolean list to specify whether an element should be returned or not.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">arr</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">5</span><span class="pl-kos">,</span> <span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">15</span><span class="pl-kos">,</span> <span class="pl-c1">20</span><span class="pl-kos">,</span> <span class="pl-c1">25</span><span class="pl-kos">]</span>
<span class="pl-s1">arr</span><span class="pl-kos">[</span><span class="pl-c1">false</span><span class="pl-kos">,</span> <span class="pl-c1">false</span><span class="pl-kos">,</span> <span class="pl-c1">true</span><span class="pl-kos">,</span> <span class="pl-c1">true</span><span class="pl-kos">,</span> <span class="pl-c1">true</span><span class="pl-kos">]</span>
<span class="pl-c">#[15, 20, 25]</span></pre></div>
<p>Combining this with boolean array operations give you a powerful filtering operation.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">arr</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">5</span><span class="pl-kos">,</span> <span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">15</span><span class="pl-kos">,</span> <span class="pl-c1">20</span><span class="pl-kos">,</span> <span class="pl-c1">25</span><span class="pl-kos">]</span>
<span class="pl-s1">arr</span> &gt; <span class="pl-c1">10</span>
<span class="pl-c"># [false, false, true, true, true]</span>
<span class="pl-s1">arr</span><span class="pl-kos">[</span><span class="pl-s1">arr</span> &gt; <span class="pl-c1">10</span><span class="pl-kos">]</span>   <span class="pl-c"># Read as arr where arr is greater than 10</span>
<span class="pl-c"># [15, 20, 25]</span>
<span class="pl-s1">arr</span><span class="pl-kos">[</span><span class="pl-s1">arr</span> % <span class="pl-c1">10</span> == <span class="pl-c1">0</span><span class="pl-kos">]</span>
<span class="pl-c"># [10, 20]</span></pre></div>
<p>And that's just for starters. With functions, you'll be able to slice and dice through any dataset with ease.</p>
<h2>
<a id="user-content-pattern-matching-maps" class="anchor" href="#pattern-matching-maps" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pattern Matching Maps</h2>
<p>Mapping defines the relationship or association between elements.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-en">greetings</span>:
    "<span class="pl-en">English</span><span class="pl-s">": "</span><span class="pl-en">Hello!</span><span class="pl-s">"</span>
<span class="pl-s">    "</span><span class="pl-en">Hindi</span><span class="pl-s">": "</span><span class="pl-en">नमस्ते</span><span class="pl-s">"</span>
<span class="pl-s">    "</span><span class="pl-en">Malayalam</span><span class="pl-s">": "</span><span class="pl-en">നമസ്കാരം</span><span class="pl-s">"</span>
<span class="pl-s">    "</span><span class="pl-en">Spanish</span><span class="pl-s">": "</span><span class="pl-en">Hola!</span><span class="pl-s">"</span>
<span class="pl-s">    "</span><span class="pl-en">Computer</span><span class="pl-s">": "</span><span class="pl-en">beep</span> <span class="pl-en">boop</span> <span class="pl-en">bop</span> <span class="pl-en">beep</span>"</pre></div>
<p>Just like list indexing, you can access a map by a key or a list of keys.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-en">greetings</span><span class="pl-kos">[</span><span class="pl-s">"English"</span><span class="pl-kos">]</span>
<span class="pl-c"># "Hello!"</span></pre></div>
<p>Let's give a customary greeting back to our computer</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">words</span> <span class="pl-c1">=</span> <span class="pl-en">greetings</span><span class="pl-kos">[</span><span class="pl-s">"Computer"</span><span class="pl-kos">]</span><span class="pl-kos">.</span><span class="pl-en">split</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
<span class="pl-c"># ["beep", "boop", "bop", "beep!"]</span>
<span class="pl-s1">words</span><span class="pl-kos">.</span><span class="pl-en">join</span><span class="pl-kos">(</span><span class="pl-s">"! "</span><span class="pl-kos">)</span>
<span class="pl-c"># beep! boop! bop! beep!</span></pre></div>
<p>You can use maps as objects</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-en">movie</span>:
    <span class="pl-en">title</span>: <span class="pl-s">"Inception"</span>
    <span class="pl-en">year</span>: <span class="pl-c1">2010</span>
    <span class="pl-en">director</span>: <span class="pl-kos">[</span><span class="pl-s">"Christopher Nolan"</span><span class="pl-kos">]</span>
    <span class="pl-en">music</span>: <span class="pl-kos">[</span><span class="pl-s">"Hans Zimmer"</span><span class="pl-kos">]</span>
    <span class="pl-en">genre</span>: <span class="pl-kos">[</span><span class="pl-pds">:sci_fi</span><span class="pl-kos">,</span> <span class="pl-pds">:action</span><span class="pl-kos">,</span> <span class="pl-pds">:adventure</span><span class="pl-kos">]</span>

<span class="pl-en">movie</span><span class="pl-kos">.</span><span class="pl-en">title</span>     <span class="pl-c"># "Inception"</span></pre></div>
<p>This object is made up of mappings from symbolic names to their values. Symbols are not strings. Symbols represent an abstract idea, like the concept of <code>true</code>, <code>null</code> or <code>:title</code>. All of the keywords, function names and attributes you see in code are symbols. Once compiled, their attribute names don't matter, just the concepts they represent.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-en">movie</span><span class="pl-kos">.</span><span class="pl-en">title</span>       <span class="pl-c"># "Inception"</span>
<span class="pl-en">movie</span><span class="pl-kos">[</span><span class="pl-s">"title"</span><span class="pl-kos">]</span>    <span class="pl-c"># null</span>
<span class="pl-en">movie</span><span class="pl-kos">[</span><span class="pl-pds">:title</span><span class="pl-kos">]</span>     <span class="pl-c"># "Inception"</span></pre></div>
<p>The <code>:</code> (association) operator allows you to define maps, enclosed by their whitespace block. You can also define a map inline using curly braces <code>{ }</code>.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-en">movie</span>: <span class="pl-kos">{</span><span class="pl-pds">title</span>: <span class="pl-s">"Wall-E"</span><span class="pl-kos">,</span> <span class="pl-pds">year</span>: <span class="pl-c1">2008</span><span class="pl-kos">,</span> <span class="pl-pds">genre</span>: <span class="pl-kos">[</span><span class="pl-pds">:animation</span><span class="pl-kos">,</span> <span class="pl-pds">:adventure</span><span class="pl-kos">,</span> <span class="pl-pds">:family</span><span class="pl-kos">]</span><span class="pl-kos">}</span></pre></div>
<h3>
<a id="user-content-pattern-matching" class="anchor" href="#pattern-matching" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pattern Matching</h3>
<p>Maps support all kinds of keys beyond just basic types.
Here we have a mapping from numerical grade to a letter grade using ranges.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-en">grades</span>:
    <span class="pl-c1">90</span>..<span class="pl-c1">100</span>: <span class="pl-s">"A"</span>
    <span class="pl-c1">80</span>..<span class="pl-c1">90</span>: <span class="pl-s">"B"</span>
    <span class="pl-c1">70</span>..<span class="pl-c1">80</span>: <span class="pl-s">"C"</span>
    <span class="pl-c1">60</span>..<span class="pl-c1">70</span>: <span class="pl-s">"D"</span>
    <span class="pl-c1">0</span>..<span class="pl-c1">60</span>: <span class="pl-s">"F"</span>

<span class="pl-en">grades</span><span class="pl-kos">(</span><span class="pl-c1">83</span><span class="pl-kos">)</span>
<span class="pl-c"># B</span></pre></div>
<p>// TODO: Pattern matching destructuring</p>
<h3>
<a id="user-content-conditionals" class="anchor" href="#conditionals" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Conditionals</h3>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">happy</span> <span class="pl-c1">=</span> <span class="pl-c1">true</span>
<span class="pl-s1">know_it</span> <span class="pl-c1">=</span> <span class="pl-c1">true</span>

<span class="pl-k">if</span> <span class="pl-s1">happy</span> <span class="pl-k">and</span> <span class="pl-s1">know_it</span>:
    "<span class="pl-v">Clap</span><span class="pl-s">"</span>
<span class="pl-s">else:</span>
<span class="pl-s">    "</span>:<span class="pl-kos">(</span>"</pre></div>
<p>The values <code>false</code>, <code>null</code>, <code>0</code>, <code>[]</code> and <code>{}</code> are considered logically false. Everything else is considered true.
Since AppAssembly is built on immutable values, the <code>==</code> operator checks whether two <strong>values</strong> are equal, rather than checking if they share the same memory location. So two lists are equal when they contain the same values. Equality on maps and sets check for the same keys and values, irrespective of order.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-kos">[</span><span class="pl-c1">0</span><span class="pl-kos">,</span> <span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-c1">3</span><span class="pl-kos">,</span> <span class="pl-c1">4</span><span class="pl-kos">]</span> == <span class="pl-kos">[</span><span class="pl-c1">0</span>..<span class="pl-c1">5</span><span class="pl-kos">]</span>
<span class="pl-c"># true</span></pre></div>
<p>Conditionals are expressions too, so you can assign the result of a conditional to a variable</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">n</span> <span class="pl-c1">=</span> <span class="pl-c1">10</span>
<span class="pl-c"># Inline using 'then' in place of :</span>
<span class="pl-en">odd_or_even</span> <span class="pl-c1">=</span> <span class="pl-k">if</span> <span class="pl-s1">n</span> % <span class="pl-c1">2</span> == <span class="pl-c1">0</span> <span class="pl-k">then</span> <span class="pl-s">"Even"</span> <span class="pl-k">else</span> <span class="pl-s">"Odd"</span>
<span class="pl-c"># Or written in multiple lines</span>
<span class="pl-en">odd_or_even</span> <span class="pl-c1">=</span> <span class="pl-k">if</span> <span class="pl-s1">n</span> % <span class="pl-c1">2</span> == <span class="pl-c1">0</span>:
    "<span class="pl-v">Even</span><span class="pl-s">"</span>
<span class="pl-s">else:</span>
<span class="pl-s">    "</span><span class="pl-v">Odd</span>"</pre></div>
<p>You can add multiple conditional branches using <code>else if</code>.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-k">if</span> <span class="pl-en">n</span> % <span class="pl-c1">3</span> <span class="pl-k">and</span> <span class="pl-en">n</span> % <span class="pl-c1">5</span> == <span class="pl-c1">0</span>:
    "<span class="pl-v">FizzBuzz</span><span class="pl-s">"</span>
<span class="pl-s">else if n % 3 == 0:</span>
<span class="pl-s">    "</span><span class="pl-v">Fizz</span><span class="pl-s">"</span>
<span class="pl-s">else if n % 5 == 0:</span>
<span class="pl-s">    "</span><span class="pl-v">Buzz</span>"
<span class="pl-k">else</span>:
    <span class="pl-en">n</span><span class="pl-k"></span></pre></div>
<h3>
<a id="user-content-set-table-and-matrix" class="anchor" href="#set-table-and-matrix" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Set, Table and Matrix</h3>
<p>...</p>
<h2>
<a id="user-content-functions-are-a-superpower" class="anchor" href="#functions-are-a-superpower" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Functions are a Superpower</h2>
<p>A function is an abstract mapping from some input to some output, allowing you to define general relationships between data. So functions are just abstract maps.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-en">add</span><span class="pl-kos">(</span><span class="pl-en">a</span><span class="pl-kos">,</span> <span class="pl-en">b</span><span class="pl-kos">)</span>: <span class="pl-en">a</span> + <span class="pl-en">b</span>
<span class="pl-en">add</span><span class="pl-kos">(</span><span class="pl-c1">5</span><span class="pl-kos">,</span> <span class="pl-c1">4</span><span class="pl-kos">)</span>
<span class="pl-c"># 9</span></pre></div>
<p>The best type of code is just data. Data is plain, simple and easy to understand. It's practically equivalent to the unit tests you may write for it. Functions can be defined as just lookup tables of plain data, or as calculations. Whatever suits the problem.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-en">fibo</span>:
    <span class="pl-c1">0</span>: <span class="pl-c1">1</span>
    <span class="pl-c1">1</span>: <span class="pl-c1">1</span>
    <span class="pl-kos">(</span><span class="pl-en">n</span><span class="pl-kos">)</span>: <span class="pl-en">fibo</span><span class="pl-kos">(</span><span class="pl-en">n</span>-<span class="pl-c1">1</span><span class="pl-kos">)</span> + <span class="pl-en">fibo</span><span class="pl-kos">(</span><span class="pl-en">n</span>-<span class="pl-c1">2</span><span class="pl-kos">)</span></pre></div>
<p>This recursive definition of fibonnaci is elegant, but not the most efficient since it'll have to re-calculate the fibonnaci numbers repeatedly. Let's use a function to show the range expression how to generate the n'th fibonnaci number from previous elements.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">fibo</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-kos">(</span><span class="pl-s1">index</span><span class="pl-kos">,</span> <span class="pl-s1">arr</span><span class="pl-kos">)</span>: <span class="pl-s1">arr</span><span class="pl-kos">[</span>-<span class="pl-c1">1</span><span class="pl-kos">]</span> + <span class="pl-s1">arr</span><span class="pl-kos">[</span>-<span class="pl-c1">2</span><span class="pl-kos">]</span><span class="pl-kos">,</span> ..<span class="pl-kos">]</span>
<span class="pl-c"># 1, 1, 2, 3, 5, 8, 13 ...</span></pre></div>
<p>There! We have an infinite sequence of all of the fibonnaci numbers. We can index into this list, and it'll generate just enough of the list to return our result.</p>
<p>There's actually a formula to calculate the n'th fibonnaci number in constant time, without needing to know the previous elements.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-en">binet_formula</span><span class="pl-kos">(</span><span class="pl-en">n</span><span class="pl-kos">)</span>:
    <span class="pl-s1">phi</span> <span class="pl-c1">=</span> <span class="pl-kos">(</span><span class="pl-en">sqrt</span><span class="pl-kos">(</span><span class="pl-c1">5</span><span class="pl-kos">)</span> + <span class="pl-c1">1</span><span class="pl-kos">)</span> / <span class="pl-c1">2</span>
    <span class="pl-s1">reciprocal</span> <span class="pl-c1">=</span> -<span class="pl-c1">1</span> / <span class="pl-s1">phi</span>
    <span class="pl-en">round</span><span class="pl-kos">(</span><span class="pl-kos">(</span><span class="pl-s1">phi</span>^<span class="pl-en">n</span> - <span class="pl-s1">reciprocal</span>^<span class="pl-en">n</span><span class="pl-kos">)</span> / <span class="pl-en">sqrt</span><span class="pl-kos">(</span><span class="pl-c1">5</span><span class="pl-kos">)</span><span class="pl-kos">)</span></pre></div>
<p>Just like everything else in AppAssembly, functions are expressions, which means they always return a value. When a function contains multiple lines, it'll return the result of the last expression.</p>
<p>Now that we have a formula to calculate a fibonnaci number, we can easily generate a list of all of them.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">fibo_seq</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-en">binet_formula</span><span class="pl-kos">,</span> ..<span class="pl-kos">]</span>
<span class="pl-c"># [1, 1, 2, 3, 5, 8, 13, ..]</span>
<span class="pl-s1">fibo_seq</span><span class="pl-kos">[</span><span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">20</span><span class="pl-kos">,</span> <span class="pl-c1">30</span><span class="pl-kos">]</span>     <span class="pl-c"># Select the fibonnacci numbers at indices</span>
<span class="pl-c"># [55, 6765, 832040]</span></pre></div>
<p>Since this doesn't rely on the previous array elements, the generator can return arbitrary elements lazily without calculating or storing the other elements.</p>
<p>Alright, enough fibonnaci numbers. There's a lot more you can do with functions.</p>
<p>TODO: Function guards, combining functions with maps, multi-methods.</p>
<h2>
<a id="user-content-the-one-loop-for-everything" class="anchor" href="#the-one-loop-for-everything" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The One Loop <code>for</code> Everything</h2>
<p>(that you probably won't even need...)</p>
<p>Array operations, pattern matching, filtering and generators removes the need for most loops. When you do find yourself needing to write something out long-form, AppAssembly has a flexible <code>for</code> loop.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">arr</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-c1">3</span><span class="pl-kos">,</span> <span class="pl-c1">4</span><span class="pl-kos">,</span> <span class="pl-c1">5</span><span class="pl-kos">]</span>

<span class="pl-k">for</span> <span class="pl-en">x</span> <span class="pl-k">in</span> <span class="pl-s1">arr</span>:
    <span class="pl-en">x</span> + <span class="pl-c1">10</span>
<span class="pl-c"># [11, 12, 13, 14, 15]</span><span class="pl-k"></span></pre></div>
<p>You can add a second parameter to get the index as well</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-k">for</span> <span class="pl-en">index</span><span class="pl-kos">,</span> <span class="pl-en">value</span> <span class="pl-k">in</span> <span class="pl-en">arr</span>:
    <span class="pl-en">value</span> + <span class="pl-c1">10</span><span class="pl-k"></span></pre></div>
<p>Similarly, you can loop over just the keys or the keys and values in maps</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-en">months</span>: <span class="pl-kos">{</span><span class="pl-s">"January"</span>: <span class="pl-c1">1</span><span class="pl-kos">,</span> <span class="pl-s">"February"</span>: <span class="pl-c1">2</span><span class="pl-kos">,</span> <span class="pl-s">"March"</span>: <span class="pl-c1">3</span><span class="pl-kos">,</span> <span class="pl-s">"April"</span>: <span class="pl-c1">4</span><span class="pl-kos">,</span> 
        <span class="pl-s">"May"</span>: <span class="pl-c1">5</span><span class="pl-kos">,</span> <span class="pl-s">"June"</span>: <span class="pl-c1">6</span><span class="pl-kos">,</span> <span class="pl-s">"July"</span>: <span class="pl-c1">7</span><span class="pl-kos">,</span> <span class="pl-s">"August"</span>: <span class="pl-c1">8</span><span class="pl-kos">,</span> 
        <span class="pl-s">"September"</span>: <span class="pl-c1">9</span><span class="pl-kos">,</span> <span class="pl-s">"October"</span>: <span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-s">"November"</span>: <span class="pl-c1">11</span><span class="pl-kos">,</span> <span class="pl-s">"December"</span>: <span class="pl-c1">12</span><span class="pl-kos">}</span>

<span class="pl-c"># Invert the keys and values in the months map</span>
<span class="pl-k">for</span> <span class="pl-en">month_str</span><span class="pl-kos">,</span> <span class="pl-en">month_num</span> <span class="pl-k">in</span> <span class="pl-en">months</span>:
    <span class="pl-kos">{</span> <span class="pl-en">month_num</span> : <span class="pl-en">month_str</span> <span class="pl-kos">}</span></pre></div>
<p>You can loop over multiple arrays simultaneously. This often comes in useful for "zipping" values together from multiple lists.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">brr</span> <span class="pl-c1">=</span> <span class="pl-kos">[</span><span class="pl-c1">10</span><span class="pl-kos">,</span> <span class="pl-c1">20</span><span class="pl-kos">,</span> <span class="pl-c1">30</span><span class="pl-kos">,</span> <span class="pl-c1">40</span><span class="pl-kos">,</span> <span class="pl-c1">50</span><span class="pl-kos">]</span>
<span class="pl-k">for</span> <span class="pl-en">x</span> <span class="pl-k">in</span> <span class="pl-s1">arr</span><span class="pl-kos">,</span> <span class="pl-en">y</span> <span class="pl-k">in</span> <span class="pl-pds">brr</span>:
    <span class="pl-en">x</span> + <span class="pl-s1">y</span>
<span class="pl-c"># [11, 22, 33, 44, 55]</span></pre></div>
<p>The loop will terminate when you reach the end of the smaller list.
You can specify an explicit condition for whether the loop should "continue", having the iteration automatically "break" when it's false.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-k">for</span> <span class="pl-en">x</span> <span class="pl-k">in</span> <span class="pl-kos">[</span><span class="pl-c1">1</span>..<span class="pl-c1">10</span><span class="pl-kos">]</span> <span class="pl-k">if</span> <span class="pl-en">x</span> &lt; <span class="pl-c1">4</span>:
    <span class="pl-en">x</span> + <span class="pl-c1">10</span>
<span class="pl-c"># [11, 12, 13]</span></pre></div>
<p>If you leave out the iteration clause, you get a while loop that continues as long as a condition is true. Since variables in AppAssembly are immutable and scoped to their block, setting a value inside a loop won't have a side effect outside of the loop.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-c"># Hailstone sequence</span>
<span class="pl-s1">n</span> <span class="pl-c1">=</span> <span class="pl-c1">12</span>
<span class="pl-k">for</span> <span class="pl-k">if</span> <span class="pl-s1">n</span> != <span class="pl-c1">1</span>:
    <span class="pl-k">if</span> <span class="pl-s1">n</span> % <span class="pl-c1">2</span>:
        <span class="pl-s1">n</span> <span class="pl-c1">=</span> <span class="pl-s1">n</span> / <span class="pl-c1">2</span>
    <span class="pl-k">else</span>:
        <span class="pl-s1">n</span> <span class="pl-c1">=</span> <span class="pl-c1">3</span>*<span class="pl-s1">n</span> + <span class="pl-c1">1</span>
<span class="pl-c"># [12, 6, 3, 10, 5, 16, 8, 4, 2, 1]</span>
<span class="pl-c"># Outside of the loop, n remains the same.</span>
<span class="pl-s1">n</span> == <span class="pl-c1">12</span>
<span class="pl-c"># true</span></pre></div>
<h2>
<a id="user-content-types-are-the-essence-of-data" class="anchor" href="#types-are-the-essence-of-data" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Types are the Essence of Data</h2>
<p>Types are a set, class or category of data. They define the essential properties of the members of that type, allowing you to operate on them with clearly stated assumptions. A good type definition will make your code faster, safer and cleaner. Types are completely optional in AppAssembly. If you find yourself doing a lot of <code>if</code> validation checks within your function, that may be a good place to use types.</p>
<p>For example, here's a Movie type stating that all movies have a <code>name</code> and <code>release_date</code>.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-v">Movie</span>:
    <span class="pl-en">String</span> <span class="pl-en">name</span>
    <span class="pl-en">Date</span> <span class="pl-en">released_on</span></pre></div>
<p>We can require a parameter to be of a particular type in the function signature, and then use it with confidence in the function body.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-en">get_snippet</span><span class="pl-kos">(</span><span class="pl-v">Movie</span> <span class="pl-en">movie</span><span class="pl-kos">)</span>:
    <span class="pl-en">movie</span><span class="pl-kos">.</span><span class="pl-en">title</span> + <span class="pl-s">" ("</span> + <span class="pl-en">movie</span><span class="pl-kos">.</span><span class="pl-en">released_on</span><span class="pl-kos">.</span><span class="pl-en">year</span> + <span class="pl-s">")"</span></pre></div>
<p>Any Map that meets the type specification can be explicitly cast into a Movie.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-s1">wall_e</span> <span class="pl-c1">=</span> <span class="pl-kos">{</span><span class="pl-pds">name</span>: <span class="pl-s">"Wall-E"</span><span class="pl-kos">,</span> <span class="pl-pds">released_on</span>: <span class="pl-en">Date</span><span class="pl-kos">(</span><span class="pl-c1">2008</span><span class="pl-kos">,</span> <span class="pl-c1">07</span><span class="pl-kos">,</span> <span class="pl-c1">27</span><span class="pl-kos">)</span><span class="pl-kos">}</span>
<span class="pl-en">Movie</span> <span class="pl-s1">wall_e</span> <span class="pl-c1">=</span> <span class="pl-s1">wall_e</span> <span class="pl-en">as</span> <span class="pl-v">Movie</span>      <span class="pl-c"># Cast wall_e to the type Movie</span></pre></div>
<p>Constructors make it easier to create instances of a type. They always have the same name as the type.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-v">Movie</span>:
    <span class="pl-en">Movie</span><span class="pl-kos">(</span><span class="pl-v">String</span> <span class="pl-en">name</span><span class="pl-kos">,</span> <span class="pl-v">Date</span> <span class="pl-en">released_on</span><span class="pl-kos">)</span>

<span class="pl-s1">life_of_pi</span> <span class="pl-c1">=</span> <span class="pl-en">Movie</span><span class="pl-kos">(</span><span class="pl-s">"Life of Pi"</span><span class="pl-kos">,</span> <span class="pl-en">Date</span><span class="pl-kos">(</span><span class="pl-c1">2012</span><span class="pl-kos">,</span> <span class="pl-c1">11</span><span class="pl-kos">,</span> <span class="pl-c1">21</span><span class="pl-kos">)</span><span class="pl-kos">)</span></pre></div>
<p>This gives you a default constructor that automatically initializes the fields.
You can add methods to a class.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-v">Counter</span>:
    <span class="pl-en">Counter</span><span class="pl-kos">(</span><span class="pl-v">Integer</span> <span class="pl-en">count</span><span class="pl-kos">)</span>
    <span class="pl-en">inc</span><span class="pl-kos">(</span><span class="pl-kos">)</span>: <span class="pl-en">this</span><span class="pl-kos">.</span><span class="pl-en">count</span> + <span class="pl-c1">1</span>
    <span class="pl-en">dec</span><span class="pl-kos">(</span><span class="pl-kos">)</span>: <span class="pl-en">count</span> - <span class="pl-c1">1</span>        <span class="pl-c"># The "this" keyword is implicit when referencing instance variables defined in the class</span>

<span class="pl-en">c1</span> <span class="pl-c1">=</span> <span class="pl-en">Counter</span><span class="pl-kos">(</span><span class="pl-c1">9</span><span class="pl-kos">)</span>
<span class="pl-en">c2</span> <span class="pl-c1">=</span> <span class="pl-en">c1</span><span class="pl-kos">.</span><span class="pl-en">inc</span><span class="pl-kos">(</span><span class="pl-kos">)</span>
<span class="pl-c"># c2 = Counter(10)</span></pre></div>
<p>Methods allow you to group data together with the behaviors that operate on them. Here, the increment and decrement methods give you back a <em>new</em> instance of Counter. When you do <code>this.count + 1</code>, the result of that operation is a new instance of <code>this</code> with count incremented. At the end of this, c1 still has a count of 9, while we have a new counter, c2, with a count of 10. What if you wanted to modify c1 in-place? You'll see how to do that with Concurrent Actions, soon!
The <code>this</code> keyword is implicitly present in all objects and allow you to unambiguously refer to the object's attributes.
To define static class methods that are shared by all instances, define them under the Class's name.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-v">Counter</span>:
    <span class="pl-en">Counter</span><span class="pl-kos">(</span><span class="pl-v">Integer</span> <span class="pl-en">count</span><span class="pl-kos">)</span>
    <span class="pl-en">inc</span><span class="pl-kos">(</span><span class="pl-kos">)</span>: <span class="pl-en">this</span><span class="pl-kos">.</span><span class="pl-en">count</span> + <span class="pl-c1">1</span>
    <span class="pl-en">dec</span><span class="pl-kos">(</span><span class="pl-kos">)</span>: <span class="pl-en">count</span> - <span class="pl-c1">1</span>
    <span class="pl-v">Counter</span><span class="pl-kos">.</span><span class="pl-en">max_count</span>: <span class="pl-c1">100</span>

<span class="pl-c"># Call class methods by the class name</span>
<span class="pl-v">Counter</span><span class="pl-kos">.</span><span class="pl-en">max_count</span></pre></div>
<p>In the next section, you'll see how this is used to implement interfaces and extension functions.</p>
<p>Since these classes are defined just like functions and maps, we can pass parameters to use them as Generic Classes.</p>
<div class="highlight highlight-source-ruby"><pre><span class="pl-v">Counter</span><span class="pl-kos">(</span><span class="pl-c1">T</span><span class="pl-kos">)</span>:
    <span class="pl-en">Counter</span><span class="pl-kos">(</span><span class="pl-c1">T</span> <span class="pl-en">count</span><span class="pl-kos">)</span>
    <span class="pl-en">inc</span><span class="pl-kos">(</span><span class="pl-c1">T</span> <span class="pl-en">amount</span><span class="pl-kos">)</span>: <span class="pl-en">count</span> + <span class="pl-en">amount</span>

<span class="pl-v">IntCounter</span> <span class="pl-c1">=</span> <span class="pl-en">Counter</span><span class="pl-kos">(</span><span class="pl-v">Integer</span><span class="pl-kos">)</span>
<span class="pl-v">FloatCounter</span> <span class="pl-c1">=</span> <span class="pl-en">Counter</span><span class="pl-kos">(</span><span class="pl-v">Float</span><span class="pl-kos">)</span></pre></div>
<p>This uses multiple dispatch to call the outer Counter generic class to create an instance of the Counter class parameterized to the type T.</p>
<h2>
<a id="user-content-designed-to-adapt" class="anchor" href="#designed-to-adapt" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Designed to Adapt</h2>
<p>It's not the fastest software that survives, nor the most elegant, but the one most adaptable to change. Change is that one constant in software we must contend with. Unfortunately software changes often mean breaking compatibility, introducing bugs or requiring a lot of cascading changes. As projects grow in size, they often become rigid and harder to change.</p>
<p>AppAssembly supports incremental software development in a number of ways. The <strong>Type System</strong> ensures that the underlying assumptions of the system remain true through changes. <strong>Multi-methods</strong> allow flexible compatibility for APIs. <strong>Extension Functions</strong> keeps libraries small and allow you adapt them to the needs of your project. <strong>Contextual Behaviors</strong> allow you to manage cross-cutting concerns without rippling changes. <strong>Cross-Project Refactoring</strong> extends tooling support for common refactoring tasks to work across project and library boundaries, without requiring manual effort.</p>
<h3>
<a id="user-content-extensible-modules-with-cross-project-refactoring" class="anchor" href="#extensible-modules-with-cross-project-refactoring" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Extensible Modules with Cross-Project Refactoring</h3>
<h3>
<a id="user-content-the-right-embedded-language-for-the-job" class="anchor" href="#the-right-embedded-language-for-the-job" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Right (Embedded) Language for the Job</h3>
<h2>
<a id="user-content-concurrent-by-default" class="anchor" href="#concurrent-by-default" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Concurrent by Default</h2>
<p>Moore's law is dead. Single threaded performance of CPUs aren't increasing as fast as they used to.
Most of the performance gains in the future are going to come from parallel and distributed computing. The traditional, imperative paradigm of software as a sequence of mutable instructions falls apart in a concurrent world where many things happen simultaneously.</p>
<h2>
<a id="user-content-resilient-error-handling" class="anchor" href="#resilient-error-handling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Resilient Error Handling</h2>
<h2>
<a id="user-content-whats-next" class="anchor" href="#whats-next" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What's Next?</h2>

              </article>
            </div>
          </div>
        </div>
      </div>

    

  </div>
  <div>&nbsp;</div>
  </div>
{% endblock %}

{% block extra_js %}
<script>
    function showCanonicalImages() {
      var images = document.getElementsByTagName('img');
      if (!images) {
        return;
      }
      for (var index = 0; index < images.length; index++) {
        var image = images[index];
        if (image.getAttribute('data-canonical-src') && image.src !== image.getAttribute('data-canonical-src')) {
          image.src = image.getAttribute('data-canonical-src');
        }
      }
    }

    function scrollToHash() {
      if (location.hash && !document.querySelector(':target')) {
        var element = document.getElementById('user-content-' + location.hash.slice(1));
        if (element) {
           element.scrollIntoView();
        }
      }
    }

    function autorefreshContent(eventSourceUrl) {
      var initialTitle = document.title;
      var contentElement = document.getElementById('grip-content');
      var source = new EventSource(eventSourceUrl);
      var isRendering = false;

      source.onmessage = function(ev) {
        var msg = JSON.parse(ev.data);
        if (msg.updating) {
          isRendering = true;
          document.title = '(Rendering) ' + document.title;
        } else {
          isRendering = false;
          document.title = initialTitle;
          contentElement.innerHTML = msg.content;
          showCanonicalImages();
        }
      }

      source.onerror = function(e) {
        if (e.readyState === EventSource.CLOSED && isRendering) {
          isRendering = false;
          document.title = initialTitle;
        }
      }
    }

    window.onhashchange = function() {
      scrollToHash();
    }

    window.onload = function() {
      scrollToHash();
    }

    showCanonicalImages();

    var autorefreshUrl = document.getElementById('preview-page').getAttribute('data-autorefresh-url');
    if (autorefreshUrl) {
      autorefreshContent(autorefreshUrl);
    }    
</script>
{% endblock %}
